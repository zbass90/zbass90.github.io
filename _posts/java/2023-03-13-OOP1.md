---
title: "[OOP] 인트로"
date: 2023-03-13 +1700
categories: [Java]
tags: [Java, OOP]
---

개발 언어 가능 -> 객체 지향으로 원하는

선수 지식
private, public
클래스, 추상클래스, 인터페이스
추상메서드
상속
오버라이딩(재정의)
<br>

```
비용 LOC
여기 저기 흩어져 있는 중복 코드,
코드를 찾고 분석하는 시간이 개발자를 괴롭힘
코드 분석 시간 증가 -> 코드 변경 시간 증가

소프트웨어의 가치는 변화이다.
바꾸는데 시간이 오래걸리면 가치를 발하지 못하는 것.
Jessica Kerr : 소프트웨어를 유지보수 한다는 것은 이전처럼 동작하고 유지시키는게 아니다. 변화하는 시대에 계속 유용해야하는 것이다.
물론 현재 기능을 제대로 제공하는 것도 중요하지만, 앞으로 변화에 적응할 수 있는 것도 그 만큼 중요하다.
바꾸는데 비용이 많이 발생하면 빈번하게 바꾸기 어려움.

=> 낮은 비용으로 변화할 수 있어야함.
이를 위한 방법으로는
패러다임 : 객체 지향, 함수형, 리액티브
코드, 설계, 아키텍처 : DRY, TDD, SOLID, DDD, 클린 아키텍쳐, MSA
업무 프로세스 / 문화 : Agile, DevOps

객체 지향과 비용
캡슐화 + 다형성(추상화)




절차지향이란
데이터를 여러 프로시저에서 사용하는 것
처음에는 관계없으나 나중에 요구사항이 늘면 늘수록 관리가 어려움. 

객체 지향은
객체라는 단위로 데이터와 프로시저를 묶음
특정 객체의 데이터는 그 객체의 프로시저만 접근하도록 만듬

객체와 객체의 프로시저로 호출함
묶는 과정이 입문에는 어렵지만 코드를 수정하기가 편함(캡슐화)

객체의 핵심 -> 기능 제공
예를 들어 회원 객체라면 암호 변경하기 기능, 차단 여부 확인 하기 기능으로 예를 들 수 있다.

메소드를 이용해서 기능 명세

객체와 객체는 기능을 사용해서 연결한다
기능 사용 = 메소드 호출

객체와 객체 상호 작용을 메시지를 주고 받는다고 표현함
메시지는 메서드 호출, 리턴하는, 인셉션 메시지

getter, setter를 보통 데이터 클래스라고 부름
기능이 붙으면 객체라고 함
```


```
캡슐화
데이터 + 관련 기능 묶기
객체가 기능을 어떻게 구현했는지 외부에 감추는 것
정보 은닉 의미 포함
외부에 영향 없이 객체 내부 구현 변경 가능

캡슐화를 위한 규칙
Tell, Don’t Ask - 데이터를 달라 하지 말고 해달라고 하기
Demeter’s Law 데미테르의 법칙 - 메서드에서 생성한 객체의 메서드만 호출, 파라미터로 받은 객체의 메서드만 호출, 필드로 참조하는 객체의 메서드만 호출
```

```
다형성
여러 모습을 갖는 것
객체 지향에서는 한 객체가 여러 타입을 갖는 것

추상화
데이터나 프로세등을 의미가 비슷한 개념이나 의미있는 표현으로 정의하는 과정이다
두 가지 방식의 추상화
특정한 성질, 공통 성질(일반화)

간단한 예
DB의 user 테이블 : 아이디, 이름, 이메일
Money 클래스 : 통화, 금액
GPU : 지포스, 라데온

구현을 구현하는 클래스를 콘크리트 클래스라고 함

추상 타입을 사용하면 변경에 유연하다.
 
추상화는 의존 대상이 변경하는 시점에 하면 된다.
아직 존재하지 않는 기능에 대한 이른 추상화는 주의: 잘못된 추상화 가능성, 복잡도만 증가한다.
실제 변경,확장이 발생할 때 추상화 시도

추상화를 잘하려면
구현을 한 이유가 무엇 때문인지 생각해야한다.

개방 폐쇄 원칙(Open-Closed Principle) OCP
기능을 확장에는 열려 있지만 수정엔 닫혀있어야함.
```

```
상속과 재사용
상속을 통한. 기능 재사용시 발생할 수 있는 단점
- 상위 클래스 변경 어려움
- 클래스 증가
- 상속 오용


하위 클래스가 많이 생길수록 상위클래스를 수정하기 굉장히 어려움
캡슐화가 어려움

상속의 단점. 해결 방법 -> 조립

조립(Composition)
여러 객체를 묶어서 더 복잡한 기능을 제공
보통 필드로 다른 객체를 참조하는 방식으로 조립 또는 객체를 필요시점에 생성/구함

상복보다는 조립
상속하기에 앞서 조립으로 풀 수 없는지 검토
진짜 하위 타입인 경우에만 상속 사용
```

```
기능 분해


기능은 하위 기능으로 분해한다


기능을 누가 제공할 것인가?
기능은 곧 책임
분리한 각 기능을 알맞게 분배한다.

큰 클래스, 큰 메서드
클래스나 메서드가 커지면 절차 지향의 문제가 발생한다
큰 클래스 -> 많은 필드를 많은 메서드가 공유
큰 메서드 -> 많은 변수를 많은 코드가 공유
여러 기능이 한 클래스/메서드에 섞여 있을 가능성이 크다
책임에 따라 알맞게 코드 분리가 필요하다.



몇 가지 책임 분배/분리 방법

패턴 적용
- 전형적인 역할 분리 : 간단한 웹(컨트롤러, 서비스, DAO), 복잡한 도메인(엔티티, 밸류, 리포지토리, 도메인 서비스), AOP(Aspect 공통기능), GoF(디자인 패턴 종류)
계산 기능 분리
- 계산에 사용하는 코드를 분리
외부 연동 분리
- 네트워크, 메시징, 파일 등 연동 처리 코드 분리
조건별 분기는 추상화
- 연속적인 if-else는 추상화 고민한다. 주의사항은 의도가 잘 드러나는 이름을 사용한다.

역할 분리가 잘 되면 테스트가 용이해진다.
```

```
의존과 DI

의존
기능 구현을 위해 다른 구성 요소를 사용하는 것.
의존의 예: 객체 생성, 메서드 호출, 데이터 사용

의존은 변경이 전파될 가능성을 의미
의존하는 대상이 바뀌면 바귈 가능성이 높아짐

예: 호출하는 메서드의 파라미터가 변경
예: 호출하느 메서드가 발생할 수 있는 익셉션 타입이 추가

순환 의존
순환 의존 -> 변경 연쇄 전파 가능성이 높다
클래스, 패키지, 모듈 등 모든 수준에서 순환 의존이 없도록 한다.

의존 대상 많을 때
1.기능 많은 경우이다.
한 클래스에서 많은 기능을 제공하는 경우이다.
각 기능마다 의존하는 대상이 다를 수 있다.
한 기능 변경이 다른 기능에 영향을 줄 수 있다.

기능 별로 분리를 고려해본다.

2. 묶어보기
몇 가지 의존 대상을 단일 기능으로 묶어서 생각해보면 의존 대상을 줄일 수 있음

의존 대상 객체를 직접 생성하면?
생성 클래스가 바뀌면 의존하는 코드도 바뀜 - 추상화에서 언급
의존 대상 객체를 직접 생성하지 않는 방법 
- 팩토리, 빌더
- 의존 주입
- 서비스 로케이터

의존 주입
외부에서 의존 객체를 주입생성자나 메서드를 이용해서 주입

조립기
조립기가 객체 생성, 의존 주입을 처리 (예: 스프링 프레임워크)
DI 장점
상위 타입을 사용할 경우, 의존 대상이 바뀌면 조립기(설정)만 변경하면 됨
의존하는 객체 없이 대역 객체를 사용해서 테스트 가능

DI를 습관처럼 사용하기
의존 객체는 주입받도록 코드 작성하는 습관

```