[ { "title": "[OOP] 인트로", "url": "/posts/OOP1/", "categories": "Java", "tags": "Java, OOP", "date": "2023-03-13 00:00:00 +0900", "snippet": "개발 언어 가능 -&gt; 객체 지향으로 원하는선수 지식private, public클래스, 추상클래스, 인터페이스추상메서드상속오버라이딩(재정의)비용 LOC여기 저기 흩어져 있는 중복 코드,코드를 찾고 분석하는 시간이 개발자를 괴롭힘코드 분석 시간 증가 -&gt; 코드 변경 시간 증가소프트웨어의 가치는 변화이다.바꾸는데 시간이 오래걸리면 가치를 발하지 못하는 것.Jessica Kerr : 소프트웨어를 유지보수 한다는 것은 이전처럼 동작하고 유지시키는게 아니다. 변화하는 시대에 계속 유용해야하는 것이다.물론 현재 기능을 제대로 제공하는 것도 중요하지만, 앞으로 변화에 적응할 수 있는 것도 그 만큼 중요하다.바꾸는데 비용이 많이 발생하면 빈번하게 바꾸기 어려움.=&gt; 낮은 비용으로 변화할 수 있어야함.이를 위한 방법으로는패러다임 : 객체 지향, 함수형, 리액티브코드, 설계, 아키텍처 : DRY, TDD, SOLID, DDD, 클린 아키텍쳐, MSA업무 프로세스 / 문화 : Agile, DevOps객체 지향과 비용캡슐화 + 다형성(추상화)절차지향이란데이터를 여러 프로시저에서 사용하는 것처음에는 관계없으나 나중에 요구사항이 늘면 늘수록 관리가 어려움. 객체 지향은객체라는 단위로 데이터와 프로시저를 묶음특정 객체의 데이터는 그 객체의 프로시저만 접근하도록 만듬객체와 객체의 프로시저로 호출함묶는 과정이 입문에는 어렵지만 코드를 수정하기가 편함(캡슐화)객체의 핵심 -&gt; 기능 제공예를 들어 회원 객체라면 암호 변경하기 기능, 차단 여부 확인 하기 기능으로 예를 들 수 있다.메소드를 이용해서 기능 명세객체와 객체는 기능을 사용해서 연결한다기능 사용 = 메소드 호출객체와 객체 상호 작용을 메시지를 주고 받는다고 표현함메시지는 메서드 호출, 리턴하는, 인셉션 메시지getter, setter를 보통 데이터 클래스라고 부름기능이 붙으면 객체라고 함캡슐화데이터 + 관련 기능 묶기객체가 기능을 어떻게 구현했는지 외부에 감추는 것정보 은닉 의미 포함외부에 영향 없이 객체 내부 구현 변경 가능캡슐화를 위한 규칙Tell, Don’t Ask - 데이터를 달라 하지 말고 해달라고 하기Demeter’s Law 데미테르의 법칙 - 메서드에서 생성한 객체의 메서드만 호출, 파라미터로 받은 객체의 메서드만 호출, 필드로 참조하는 객체의 메서드만 호출다형성여러 모습을 갖는 것객체 지향에서는 한 객체가 여러 타입을 갖는 것추상화데이터나 프로세등을 의미가 비슷한 개념이나 의미있는 표현으로 정의하는 과정이다두 가지 방식의 추상화특정한 성질, 공통 성질(일반화)간단한 예DB의 user 테이블 : 아이디, 이름, 이메일Money 클래스 : 통화, 금액GPU : 지포스, 라데온구현을 구현하는 클래스를 콘크리트 클래스라고 함추상 타입을 사용하면 변경에 유연하다. 추상화는 의존 대상이 변경하는 시점에 하면 된다.아직 존재하지 않는 기능에 대한 이른 추상화는 주의: 잘못된 추상화 가능성, 복잡도만 증가한다.실제 변경,확장이 발생할 때 추상화 시도추상화를 잘하려면구현을 한 이유가 무엇 때문인지 생각해야한다.개방 폐쇄 원칙(Open-Closed Principle) OCP기능을 확장에는 열려 있지만 수정엔 닫혀있어야함.상속과 재사용상속을 통한. 기능 재사용시 발생할 수 있는 단점- 상위 클래스 변경 어려움- 클래스 증가- 상속 오용하위 클래스가 많이 생길수록 상위클래스를 수정하기 굉장히 어려움캡슐화가 어려움상속의 단점. 해결 방법 -&gt; 조립조립(Composition)여러 객체를 묶어서 더 복잡한 기능을 제공보통 필드로 다른 객체를 참조하는 방식으로 조립 또는 객체를 필요시점에 생성/구함상복보다는 조립상속하기에 앞서 조립으로 풀 수 없는지 검토진짜 하위 타입인 경우에만 상속 사용기능 분해기능은 하위 기능으로 분해한다기능을 누가 제공할 것인가?기능은 곧 책임분리한 각 기능을 알맞게 분배한다.큰 클래스, 큰 메서드클래스나 메서드가 커지면 절차 지향의 문제가 발생한다큰 클래스 -&gt; 많은 필드를 많은 메서드가 공유큰 메서드 -&gt; 많은 변수를 많은 코드가 공유여러 기능이 한 클래스/메서드에 섞여 있을 가능성이 크다책임에 따라 알맞게 코드 분리가 필요하다.몇 가지 책임 분배/분리 방법패턴 적용- 전형적인 역할 분리 : 간단한 웹(컨트롤러, 서비스, DAO), 복잡한 도메인(엔티티, 밸류, 리포지토리, 도메인 서비스), AOP(Aspect 공통기능), GoF(디자인 패턴 종류)계산 기능 분리- 계산에 사용하는 코드를 분리외부 연동 분리- 네트워크, 메시징, 파일 등 연동 처리 코드 분리조건별 분기는 추상화- 연속적인 if-else는 추상화 고민한다. 주의사항은 의도가 잘 드러나는 이름을 사용한다.역할 분리가 잘 되면 테스트가 용이해진다.의존과 DI의존기능 구현을 위해 다른 구성 요소를 사용하는 것.의존의 예: 객체 생성, 메서드 호출, 데이터 사용의존은 변경이 전파될 가능성을 의미의존하는 대상이 바뀌면 바귈 가능성이 높아짐예: 호출하는 메서드의 파라미터가 변경예: 호출하느 메서드가 발생할 수 있는 익셉션 타입이 추가순환 의존순환 의존 -&gt; 변경 연쇄 전파 가능성이 높다클래스, 패키지, 모듈 등 모든 수준에서 순환 의존이 없도록 한다.의존 대상 많을 때1.기능 많은 경우이다.한 클래스에서 많은 기능을 제공하는 경우이다.각 기능마다 의존하는 대상이 다를 수 있다.한 기능 변경이 다른 기능에 영향을 줄 수 있다.기능 별로 분리를 고려해본다.2. 묶어보기몇 가지 의존 대상을 단일 기능으로 묶어서 생각해보면 의존 대상을 줄일 수 있음의존 대상 객체를 직접 생성하면?생성 클래스가 바뀌면 의존하는 코드도 바뀜 - 추상화에서 언급의존 대상 객체를 직접 생성하지 않는 방법 - 팩토리, 빌더- 의존 주입- 서비스 로케이터의존 주입외부에서 의존 객체를 주입생성자나 메서드를 이용해서 주입조립기조립기가 객체 생성, 의존 주입을 처리 (예: 스프링 프레임워크)DI 장점상위 타입을 사용할 경우, 의존 대상이 바뀌면 조립기(설정)만 변경하면 됨의존하는 객체 없이 대역 객체를 사용해서 테스트 가능DI를 습관처럼 사용하기의존 객체는 주입받도록 코드 작성하는 습관" }, { "title": "[이슈] 자동화 프로젝트(feat.gitlab) - 프롤로그", "url": "/posts/Issue1/", "categories": "Issue", "tags": "tech, issue", "date": "2023-02-24 00:00:00 +0900", "snippet": "✅ 이슈안타깝게도 사내 많은 프로젝트들은(~~약 300여개~~) 소프트웨어 개발 수명 주기(Software Development Life Cycle, SDLC)가 관리되고 있지 않다.찾던 중 GitLab을 도입하여 개발 파이프라인을 구축하고자 한다.(추후 업로드 예정...)" }, { "title": "[Algorithm] 소수(에라토스테네스 체)", "url": "/posts/AlgorithmNumber5/", "categories": "Algorithm", "tags": "java, algorithm, number", "date": "2022-02-09 00:00:00 +0900", "snippet": "Question description 자연수 N이 입력되면 1부터 N까지의 소수의 개수를 출력하는 프로그램을 작성하세요. 만약 20이 입력되면 1부터 20까지의 소수는 2, 3, 5, 7, 11, 13, 17, 19로 총 8개입니다. input 첫 줄에 자연수의 개수 N(2&lt;=N&lt;=200,000)이 주어집니다. output 첫 줄에 소수의 개수를 출력합니다.   예시값 첫번째 입력 20 출력 8 Sourceimport java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader;public class Main { public static int solution(int n) { int[] arr = new int[n+1]; int count = 0; for (int i = 2; i &lt;= n; i++) { if (arr[i] == 0) { count++; for (int j = i*2; j &lt;= n; j+=i) { arr[j] = 1; } } } return count; } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); System.out.println(solution(n)); }}explanation" }, { "title": "[Algorithm] 피보나치 수열", "url": "/posts/AlgorithmNumber4/", "categories": "Algorithm", "tags": "java, algorithm, number", "date": "2022-02-08 00:00:00 +0900", "snippet": "Question description 1) 피보나키 수열을 출력한다. 피보나치 수열이란 앞의 2개의 수를 합하여 다음 숫자가 되는 수열이다. 2) 입력은 피보나치 수열의 총 항의 수 이다. 만약 7이 입력되면 1 1 2 3 5 8 13을 출력하면 된다. input 첫 줄에 총 항수 N(3&lt;=N&lt;=45)이 입력된다. output 첫 줄에 피보나치 수열을 출력합니다.   예시값 첫번째 입력 10 출력 1 1 2 3 5 8 13 21 34 55 Sourceimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader; public class Main { private static int[] memo = new int[0]; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int firstNum = Integer.parseInt(br.readLine()); memo = new int[firstNum]; fibo(firstNum-1); StringBuffer sb = new StringBuffer(); for (int n : memo) { sb.append(n).append(\" \"); } System.out.println(String.valueOf(sb).trim()); } private static int fibo(int k) { if (memo[k] == 0) { // 처음 계산되는 값 if (k &lt;= 1) { // 1번 항과 2번 항은 1로 초기화 memo[k] = 1; } else { // 3번째 항 부터는 계산 memo[k] = fibo(k - 1) + fibo(k - 2); } } return memo[k]; }}explanation재귀함수 사용 :)" }, { "title": "[Algorithm] 가위 바위 보", "url": "/posts/AlgorithmNumber3/", "categories": "Algorithm", "tags": "java, algorithm, number", "date": "2022-02-03 00:00:00 +0900", "snippet": "Question description A, B 두 사람이 가위바위보 게임을 합니다. 총 N번의 게임을 하여 A가 이기면 A를 출력하고, B가 이기면 B를 출력합니다. 비길 경우에는 D를 출력합니다. 가위, 바위, 보의 정보는 1:가위, 2:바위, 3:보로 정하겠습니다. 예를 들어 N=5이면 두 사람의 각 회의 가위/바위/보 정보가 주어지면 각 회를 누가 이겼는지 출력 프로그램을 작성하세요. input 첫 번째 줄에 게임 횟수인 자연수 N(1&lt;=N&lt;=100)이 주어집니다. 두 번째 줄에는 A가 낸 가위, 바위, 보 정보가 N개 주어집니다. 세 번째 줄에는 B가 낸 가위, 바위, 보 정보가 N개 주어집니다. output 각 줄에 각 회의 승자를 출력합니다. 비겼을 경우는 D를 출력합니다.   예시값 첫번째 입력 5 두번째 입력 2 3 3 1 3 세번째 입력 1 1 2 2 3 출력 ABABD Sourceimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int firstNum = Integer.parseInt(br.readLine()); Main m = new Main(); int[] firstArr = m.tokenList(firstNum, br.readLine()); int[] secondArr = m.tokenList(firstNum, br.readLine()); for(int i=0; i &lt; firstNum; i++){ System.out.println(m.compareValue(firstArr[i], secondArr[i])); } } public int[] tokenList(int firstNum, String br){ StringTokenizer numberToken = new StringTokenizer(br); int[] intList = new int[firstNum]; int cnt = 0; while(numberToken.hasMoreTokens()){ intList[cnt++] = Integer.parseInt(numberToken.nextToken()); } return intList; } public String compareValue(int a, int b) { //가위, 바위, 보의 정보는 1:가위, 2:바위, 3:보로 정하겠습니다 if(a == b) return \"D\"; else if(a == 2 &amp;&amp; b == 1) return \"A\"; else if( a == 3 &amp;&amp; b == 2) return \"A\"; else if( a == 1 &amp;&amp; b == 3) return \"A\"; else return \"B\"; }}explanation…" }, { "title": "[Algorithm] 보이는 학생", "url": "/posts/AlgorithmNumber2/", "categories": "Algorithm", "tags": "java, algorithm, number", "date": "2022-02-02 00:00:00 +0900", "snippet": "Question description 선생님이 N명의 학생을 일렬로 세웠습니다. 일렬로 서 있는 학생의 키가 앞에서부터 순서대로 주어질 때, 맨 앞에 서 있는 선생님이 볼 수 있는 학생의 수를 구하는 프로그램을 작성하세요. (앞에 서 있는 사람들보다 크면 보이고, 작거나 같으면 보이지 않습니다.) input 첫 줄에 정수 N(5&lt;=N&lt;=100,000)이 입력된다. 그 다음줄에 N명의 학생의 키가 앞에서부터 순서대로 주어진다. output 선생님이 볼 수 있는 최대학생수를 출력한다.   예시값 첫번째 입력 8 두번째 입력 130 135 148 140 145 150 150 153 출력 5 Sourceimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int firstNum = Integer.parseInt(br.readLine()); StringTokenizer secondNums = new StringTokenizer(br.readLine()); StringBuffer sb = new StringBuffer(); int[] intList = new int[firstNum]; int cnt = 0; while(secondNums.hasMoreTokens()){ intList[cnt++] = Integer.parseInt(secondNums.nextToken()); } int maxNum = intList[0]; int result = 1; for(int i=1; i &lt; firstNum; i++){ if(maxNum &lt; intList[i]) { result++; maxNum = intList[i]; } } System.out.println(result); }}explanation…" }, { "title": "[Algorithm] 큰 수 출력하기", "url": "/posts/AlgorithmNumber1/", "categories": "Algorithm", "tags": "java, algorithm, number", "date": "2022-02-01 00:00:00 +0900", "snippet": "Question description N개의 정수를 입력받아, 자신의 바로 앞 수보다 큰 수만 출력하는 프로그램을 작성하세요. (첫 번째 수는 무조건 출력한다) input 첫 줄에 자연수 N(1&lt;=N&lt;=100) output 자신의 바로 앞 수보다 큰 수만 한 줄로 출력한다.   예시값 첫번째 입력 6 두번째 입력 7 3 9 5 6 12 출력 7 9 6 12 Sourceimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int firstNum = Integer.parseInt(br.readLine()); StringTokenizer secondNums = new StringTokenizer(br.readLine()); StringBuffer sb = new StringBuffer(); int[] intList = new int[firstNum]; int cnt = 0; while(secondNums.hasMoreTokens()){ intList[cnt++] = Integer.parseInt(secondNums.nextToken()); } for(int i=0; i &lt; firstNum; i++){ if(i == 0 ){ sb.append(intList[i]).append(\" \"); } if(i &gt; 0 &amp;&amp; intList[i] &gt; intList[i-1]){ sb.append(intList[i]).append(\" \"); } } System.out.println(String.valueOf(sb).trim()); }}explanation…" }, { "title": "[Algorithm] 암호", "url": "/posts/Algorithm11/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-28 00:00:00 +0900", "snippet": "Question description 현수는 영희에게 알파벳 대문자로 구성된 비밀편지를 매일 컴퓨터를 이용해 보냅니다. 비밀편지는 현수와 영희가 서로 약속한 암호로 구성되어 있습니다. 비밀편지는 알파벳 한 문자마다 # 또는 이 일곱 개로 구성되어 있습니다. 만약 현수가 “#**#”으로 구성된 문자를 보냈다면 영희는 현수와 약속한 규칙대로 다음과 같이 해석합니다. “#*****#”를 일곱자리의 이진수로 바꿉니다. #은 이진수의 1로, *이진수의 0으로 변환합니다. 결과는 “1000001”로 변환됩니다. 바뀐 2진수를 10진수화 합니다. “1000001”을 10진수화 하면 65가 됩니다. 아스키 번호가 65문자로 변환합니다. 즉 아스크번호 65는 대문자 ‘A’입니다. 참고로 대문자들의 아스키 번호는 ‘A’는 65번, ‘B’는 66번, ’C’는 67번 등 차례대로 1씩 증가하여 ‘Z’는 90번입니다. 현수가 4개의 문자를 다음과 같이 신호로 보냈다면 #**###############** 이 신호를 4개의 문자신호로 구분하면 #**## –&gt; ‘C’ #**#### –&gt; ‘O’ #**#### –&gt; ‘O’ ### –&gt; ‘L’ 최종적으로 “COOL”로 해석됩니다. 현수가 보낸 신호를 해석해주는 프로그램을 작성해서 영희를 도와주세요. input 첫 줄에는 보낸 문자의 개수(10을 넘지 안습니다)가 입력된다. 다음 줄에는 문자의 개수의 일곱 배 만큼의 #또는 * 신호가 입력됩니다. 현수는 항상 대문자로 해석할 수 있는 신호를 보낸다고 가정합니다. output 영희가 해석한 문자열을 출력합니다.   예시값 첫번째 입력 4 두번째 입력 #****###**#####**#####**##** 출력 COOL Sourceimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Main { public static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int inputNum = Integer.parseInt(bf.readLine()); String inputValue = bf.readLine().trim(); int k = 0; List&lt;Character&gt; list = new ArrayList&lt;&gt;(inputNum); StringBuffer sb = new StringBuffer(); for(int i=0 ; i &lt; inputValue.length(); i += 7){ k = i + 7 ; for (char c: inputValue.substring(i, k).toCharArray()) { sb.append(c == '#' ? 1 :0); } list.add((char)Integer.parseInt(String.valueOf(sb),2)); sb.setLength(0); } Iterator listIter = list.iterator(); while(listIter.hasNext()){ System.out.print(listIter.next()); } }}explanation…" }, { "title": "[Algorithm] 문자열 압축", "url": "/posts/Algorithm10/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-27 00:00:00 +0900", "snippet": "Question description 알파벳 대문자로 이루어진 문자열을 입력받아 같은 문자가 연속으로 반복되는 경우 반복되는 문자 바로 오른쪽에 반복 횟수를 표기하는 방법으로 문자열을 압축하는 프로그램을 작성하시오. 단 반복횟수가 1인 경우 생략합니다. input 첫 줄에 문자열이 주어진다. 문자열의 길이는 100을 넘지 않는다. output 첫 줄에 압축된 문자열을 출력한다.   예시값 첫번째 입력 KKHSSSSSSSE 출력 K2HS7E 첫번째 입력 KSTTTSEEKFKKKDJJGG 출력 KST3SE2KFK3DJ2G2 Sourceimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); String alpha = bf.readLine()+\" \"; char[] alpha_arr = alpha.toCharArray(); StringBuffer sb = new StringBuffer(); int cnt = 1; for(int i = 0; i &lt; alpha_arr.length-1; i++){ char temp = alpha_arr[i+1]; if(alpha_arr[i] != temp){ sb.append(alpha_arr[i]); if(cnt &gt; 1){ sb.append(cnt); } cnt = 1; }else{ cnt++; } } System.out.println(sb); }}explanation…" }, { "title": "[Algorithm] 가장 짧은 문자거리", "url": "/posts/Algorithm9/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-25 00:00:00 +0900", "snippet": "Question description 한 개의 문자열 s와 문자 t가 주어지면 문자열 s의 각 문자가 문자 t와 떨어진 최소거리를 출력하는 프로그램을 작성하세요. input 첫 번째 줄에 문자열 s와 문자 t가 주어진다. 문자열과 문자는 소문자로만 주어집니다. 문자열의 길이는 100을 넘지 않는다. output 첫 번째 줄에 각 문자열 s의 각 문자가 문자 t와 떨어진 거리를 순서대로 출력한다.   예시값 첫번째 입력 teachermode e 출력 1 0 1 2 1 0 1 2 2 1 0 Sourceimport java.util.Scanner; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); String firstWord = sc.next(); char splitWord = sc.next().charAt(0); int[] intArr = new int[firstWord.length()]; int checkNum = 10; for(int i=0; i&lt;firstWord.length(); i++){ if(firstWord.charAt(i)==splitWord){ checkNum=0; intArr[i]=checkNum; } else{ checkNum++; intArr[i]=checkNum; } } checkNum=10; for(int i=firstWord.length()-1; i&gt;=0; i--){ if(firstWord.charAt(i)==splitWord) checkNum=0; else{ checkNum++; intArr[i]=Math.min(intArr[i], checkNum); } } for (int i : intArr) { System.out.print(i+ \" \"); } }}explanation…" }, { "title": "[Algorithm] 숫자만 추출", "url": "/posts/Algorithm8-copy/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-20 00:00:00 +0900", "snippet": "Question description 문자와 숫자가 섞여있는 문자열이 주어지면 그 중 숫자만 추출하여 그 순서대로 자연수를 만듭니다. 만약 “tge0a1h205er”에서 숫자만 추출하면 0, 1, 2, 0, 5이고 이것을 자연수를 만들면 1205이 됩니다. 추출하여 만들어지는 자연수는 100,000,000을 넘지 않습니다. input 첫 줄에 숫자가 썩인 문자열이 주어집니다. 문자열의 길이는 100을 넘지 않습니다. output 첫 줄에 자연수를 출력합니다.   예시값 첫번째 입력 g0en2T0s8eSoft 출력 208 Sourceimport java.util.Scanner;import java.util.regex.Pattern;public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); String words = sc.nextLine(); if(words.length() &gt; 100) return; StringBuilder sb = new StringBuilder(); for(int i=0; i &lt; words.length(); i++){ String word = String.valueOf(words.charAt(i)); boolean numCheck = Pattern.matches(\"^[0-9]$\", word); if(numCheck){ sb.append(word); } } System.out.println(Integer.valueOf(sb.toString())); }}explanation…" }, { "title": "[Algorithm] 유효한 팰린드롬", "url": "/posts/Algorithm8/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-18 00:00:00 +0900", "snippet": "Question description 앞에서 읽을 때나 뒤에서 읽을 때나 같은 문자열을 팰린드롬이라고 합니다. 문자열이 입력되면 해당 문자열이 팰린드롬이면 “YES”, 아니면 “NO”를 출력하는 프로그램을 작성하세요. 단 회문을 검사할 때 알파벳만 가지고 회문을 검사하며, 대소문자를 구분하지 않습니다. 알파벳 이외의 문자들의 무시합니다. input 첫 줄에 길이 100을 넘지 않는 공백이 없는 문자열이 주어집니다. output 첫 번째 줄에 팰린드롬인지의 결과를 YES 또는 NO로 출력합니다.   예시값 첫번째 입력 found7, time: study; Yduts; emit, 7Dnuof 출력 YES Sourceimport java.util.Scanner;import java.util.regex.Pattern;public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); String str1 = sc.nextLine(); StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; str1.length(); i++){ char word = str1.charAt(i); boolean alphaCheck = Pattern.matches(\"^[a-zA-Z]$\" , String.valueOf(word)); if(alphaCheck){ sb.append(word); } } for(int i = 0; i &lt; sb.length()/2; i++){ String firstWord = String.valueOf(sb.charAt(i)).toUpperCase(); String secondWord = String.valueOf(sb.charAt(sb.length()-1-i)).toUpperCase(); if(!firstWord.equals(secondWord)){ System.out.println(\"NO\"); return; } } System.out.println(\"YES\"); }}explanation…" }, { "title": "[Algorithm] 회문 문자열", "url": "/posts/Algorithm7/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-13 00:00:00 +0900", "snippet": "Question description 앞에서 읽을 때나 뒤에서 읽을 때나 같은 문자열을 회문 문자열이라고 합니다. 문자열이 입력되면 해당 문자열이 회문 문자열이면 “YES”, 회문 문자열이 아니면 “NO”를 출력하는 프로그램을 작성하세요. 단 회문을 검사할 때 대소문자를 구분하지 않습니다. input 첫 줄에 길이 100을 넘지 않는 공백이 없는 문자열이 주어집니다. output 첫 번째 줄에 회문 문자열인지의 결과를 YES 또는 NO로 출력합니다.   예시값 첫번째 입력 gooG 출력 YES Sourceimport java.util.Scanner; public class Main { public static void main(String[] args){ \tScanner in=new Scanner(System.in); String str = in.next(); char[] arr = str.toUpperCase().toCharArray(); String res = \"YES\"; for(int i=0; i&lt;arr.length; i++){ if(arr[i] != arr[arr.length-i-1]){ res = \"NO\"; } } System.out.println(res); }}explanation…" }, { "title": "[Algorithm] 중복문자제거", "url": "/posts/Algorithm6/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-13 00:00:00 +0900", "snippet": "Question description 소문자로 된 한개의 문자열이 입력되면 중복된 문자를 제거하고 출력하는 프로그램을 작성하세요. 중복이 제거된 문자열의 각 문자는 원래 문자열의 순서를 유지합니다. input 첫 줄에 문자열이 입력됩니다. 문자열의 길이는 100을 넘지 않는다. output 첫 줄에 중복문자가 제거된 문자열을 출력합니다.   예시값 첫번째 입력 ksekkset 출력 kset Sourceimport java.util.Scanner; public class Main { public static void main(String[] args){ Scanner in=new Scanner(System.in); String str = in.next(); char[] arr = str.toCharArray(); String res =\"\"; for(int i =0; i&lt;arr.length; i++){ if(str.indexOf(str.charAt(i)) == i ){ res+=str.charAt(i); } } System.out.println(res); }}explanation…" }, { "title": "[Algorithm] 특정 문자 뒤집기", "url": "/posts/Algorithm5/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-12 00:00:00 +0900", "snippet": "Question description 영어 알파벳과 특수문자로 구성된 문자열이 주어지면 영어 알파벳만 뒤집고, 특수문자는 자기 자리에 그대로 있는 문자열을 만들어 출력하는 프로그램을 작성하세요. input 첫 줄에 길이가 100을 넘지 않는 문자열이 주어집니다. output 첫 줄에 알파벳만 뒤집힌 문자열을 출력합니다.   예시값 첫번째 입력 a#b!GE*T@S 출력 S#T!EG*b@a Sourceimport java.util.Scanner; public class Main { public static void main(String[] args){ Scanner in=new Scanner(System.in); String str = in.next(); char[] arr = str.toCharArray(); int lt = 0; int rt = arr.length-1; //9 while(lt &lt; rt) { // 0 &lt; 9 char left = arr[lt]; char right = arr[rt]; // 문자가 소문자인지 if(!Character.isAlphabetic(left)){ lt++; // 문자가 대문자인지 } else if( !Character.isAlphabetic(right)){ rt--; }else { // 알파벳일때 교환 char tmp = arr[lt]; arr[lt] = arr[rt]; arr[rt] = tmp; lt ++; rt --; } } // char[]을 String 으로 String answer = String.valueOf(arr); System.out.println(answer); }}explanation…" }, { "title": "[Algorithm] 단어 뒤집기", "url": "/posts/Algorithm4/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-11 00:00:00 +0900", "snippet": "Question description N개의 단어가 주어지면 각 단어를 뒤집어 출력하는 프로그램을 작성하세요. input 첫 줄에 자연수 N(3&lt;=N&lt;=20)이 주어집니다. 두 번째 줄부터 N개의 단어가 각 줄에 하나씩 주어집니다. 단어는 영어 알파벳으로만 구성되어 있습니다. output N개의 단어를 입력된 순서대로 한 줄에 하나씩 뒤집어서 출력합니다.   예시값 첫번째 입력 3 두번째 입력 good 세번째 입력 Time 네번째 입력 Big 출력 doogemiTgiB Sourceimport java.util.Scanner; public class Main { public static void main(String[] args){ Scanner in=new Scanner(System.in); int input1 = in.nextInt(); String[] arr = new String[input1]; for(int i = 0 ; i &lt; arr.length ; i++){ String str = in.next(); StringBuilder sb = new StringBuilder(str); arr[i] = sb.reverse().toString(); } for(String str : arr){ System.out.println(str); } }}explanation…" }, { "title": "[Algorithm] 문장 속 단어", "url": "/posts/Algorithm3/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-06 00:00:00 +0900", "snippet": "Question description 한 개의 문장이 주어지면 그 문장 속에서 가장 긴 단어를 출력하는 프로그램을 작성하세요. 문장속의 각 단어는 공백으로 구분됩니다. input 첫 줄에 길이가 100을 넘지 않는 한 개의 문장이 주어집니다. 문장은 영어 알파벳으로만 구성되어 있습니다 output 첫 줄에 가장 긴 단어를 출력한다. 가장 길이가 긴 단어가 여러개일 경우 문장속에서 가장 앞쪽에 위치한 단어를 답으로 합니다.   예시값 첫번째 입력 it is time to study 출력 study Sourceimport java.util.Scanner;import java.util.Arrays; public class Main { public static void main(String[] args){ Scanner in=new Scanner(System.in); String input1 = in.nextLine(); String[] arr = input1.split(\" \"); String str = Arrays.stream(arr).reduce(\"\", (str1, str2) -&gt; { if(str1.getBytes().length &gt;= str2.getBytes().length){ return str1; }else{ return str2; } }); \t\tSystem.out.println(str); }}explanation…" }, { "title": "[Algorithm] 대소문자 변환", "url": "/posts/Algorithm2/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-05 00:00:00 +0900", "snippet": "Question description 대문자와 소문자가 같이 존재하는 문자열을 입력받아 대문자는 소문자로 소문자는 대문자로 변환하여 출력하는 프로그램을 작성하세요. input 첫 줄에 문자열이 입력된다. 문자열의 길이는 100을 넘지 않습니다. 문자열은 영어 알파벳으로만 구성되어 있습니다. output 첫 줄에 대문자는 소문자로, 소문자는 대문자로 변환된 문자열을 출력합니다.   예시값 첫번째 입력 StuDY 출력 sTUdy Sourceimport java.util.Scanner;import java.util.Locale;public class Main { public static void main(String[] args){ Scanner in=new Scanner(System.in); String input1 = in.next(); input1.chars() .mapToObj(i -&gt; (char)i) .map(i-&gt; { if(Character.isUpperCase(i)){ return i.toString().toLowerCase(Locale.ROOT); }else{ return i.toString().toUpperCase(Locale.ROOT); } } ) .forEach(System.out::print); }}explanation…" }, { "title": "[Blog] Jekyll의 Chirpy Theme 깃 블로그 만들기", "url": "/posts/StartingBlog/", "categories": "Blog", "tags": "blogging, chirpy, jekyll", "date": "2022-01-04 00:00:00 +0900", "snippet": "이 글의 베이스는 Chipy 공식 홈페이지의 Getting Started글이며 자세한 내용은 해당 사이트에서 확인 가능합니다.재우님의 블로그를 참고해서 빌드와 포스팅했습니다.Installation 깃허브에서 Chirpy Repo에서 포크로 담은 Repository Name을 {GithubUserName}.github.io로 변경합니다. 터미널을 켜고 Repository를 localhost로 가져옵니다. 원하는 위치로 이동하여 아래 명령어를 실행!$ git clone https://github.com/USERNAME/USERNAME.github.io.git -b master --single-branch Setting up the local environment로컬에서 블로그를 운영하려면 몇가지 설치가 필요합니다.Jekyll 설치 가이드를 참고해서 운영체제에 맞게 다운 받아주시면 됩니다.$ ruby -v$ gem -v$ gcc -v ## g++ -v, make -vRuby, gem, gcc 버전 체크 후 이상이 없다면 다음을 진행하면 됩니다.블로그 디렉토리로 이동한 후 $ bundle install 명령을 실행하면 모두 자동으로 설치됩니다.혹시 위 명령어에서 can`t find bundler와 같은 에러가 발생하였다면 Update RubyGems: $ gem update --system Install the exact Bundler: $ gem install bundler -v \"$(grep -A 1 \"BUNDLED WITH\" Gemfile.lock | tail -n 1)\" RubyGem을 업데이트 하시거나 명령어로 설치하시면 됩니다.UsageInitialization이제 프로젝트 폴더로 이동하여 아래 명령어를 통해 Initialization을 진행합니다.$ bash tools/init.sh Note: 깃허브 페이지에 배포하는 것을 원치않는다면 위 명렁어 뒤에 --no-gh옵션을 붙여 실행하면 됩니다.위 명령어를 실행하면 아래와 같은 작업들이 수행되어집니다. 특정 파일과 폴더를 삭제합니다. .travis.yml _posts 폴더 속 파일들 docs 폴더 --no-gh옵션을 붙여주었다면 .github폴더가 삭제됩니다. 그렇지 않다면, .github/workflows/pages-deploy.yml.hook의 .hook확장자 파일을 삭제함으로써 Github Action workflow를 셋업이 가능합니다. 그 후에 .github폴더의 다른 파일, 폴더들을 삭제하면 됩니다. 자동으로 commit을 생성합니다.Configuration_config.yml파일로 가서 여러가지 설정값을 변경해야 하며 아래는 대표적인 설정값입니다. _config.yml파일에서 아래에 해당하는 값들을 변경하면 됩니다. url: 블로그의 주소를 입력해주세요.e.g. url: 'https://zbass90.github.io' avatar: 대표하고 싶은 이미지 파일을 넣어주세요. 일반적으로 이미지 파일은 /assets/img/폴더에 넣고 불러서 사용합니다.e.g. avatar: /assets/img/sample.png timezone: Find your timezone에서 자신이 속한 지역을 찾아 넣어주세요.e.g. timezone: Asia/Seoul theme_mode: 블로그의 테마모드를 설정해주는 값으로, 다크와 라이트중 선택할 수 있습니다.e.g. theme_mode: dark … 저는 dark가 좋아용.Run Locally포스팅을 배포하기전에 내 로컬에서 포스팅 혹은 변경사항이 제대로 적용되었는지 아래 명령어를 통해 바로 확인 가능합니다.$ bundle exec jekyll s위 명령어를 실행하고 localhost:4000으로 접속이 가능합니다.Deploy on Github Pages 아무 변경사항을 origin/master 푸시해주어 Github Actions workflow를 발동?(trigger) 시킨다. 빌드가 제대로 완료되었다면 레포의 브랜치에 gh-pages브랜치가 생성된것을 확인할 수 있을것이다. 레포의 setting으로 들어가서 아래로 쭈욱 내리면 Github Pages에 대한 설정이 나온다. Branch를 gh-pages로 변경해준뒤 save를 클릭해주자.End_post/폴더에서 markdown파일을 작성 -&gt; Github.에 Push -&gt; 블로그에 포스팅 완료! 이상입니다." }, { "title": "[Algorithm] 문자 찾기", "url": "/posts/Algorithm1/", "categories": "Algorithm", "tags": "java, algorithm, string", "date": "2022-01-04 00:00:00 +0900", "snippet": "Question description 한 개의 문자열을 입력받고, 특정 문자를 입력받아 해당 특정문자가 입력받은 문자열에 몇 개 존재하는지 알아내는 프로그램을 작성하세요. 대소문자를 구분하지 않습니다.문자열의 길이는 100을 넘지 않습니다. input 첫 줄에 문자열이 주어지고, 두 번째 줄에 문자가 주어진다. 문자열은 영어 알파벳으로만 구성되어 있습니다. output 첫 줄에 해당 문자의 개수를 출력한다.   예시값 첫번째 입력 Computercooler 두번째 입력 c 출력 2 Sourceimport java.util.Locale;import java.util.Scanner;public class Main { public static void main(String[] args){ Scanner in=new Scanner(System.in); String input1 = in.nextLine(); String input2 = in.nextLine(); long res = countChar(input1.toUpperCase(Locale.ROOT), input2.toUpperCase().charAt(0)); System.out.println(res); } public static long countChar(String str, char ch){ return str.chars() .filter(a-&gt; a == ch) .count(); }}explanation…" } ]
